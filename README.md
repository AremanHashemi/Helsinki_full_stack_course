# Helsinki_full_stack_course

# Intro

## Callbacks
```js var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  // code that takes care of the server response
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```
> onreadstatechange is called after the request to server is sent on last line. This is an example of a event handler. Event handlers get called on change of state of certain bits.

> Invoking event handlers is done via callback mechanism where the runtime enviroment is in charge of invoking callback functions at the appropriate time.

The DOM or document object model is a treelike structure of HTML elements. 

## AJAX 
Asynchrounous Javascript and XML : allowed fetching content to web pages using javascript within the HTML. No longer need to re render the page.

## Single Page App
Only comprised of one HTML page fetched from the server, the content is then manipulated via javascript to give the feeling of multiple pages without having to make more fetch calls.

```js
var form = document.getElementById('notes_form')
form.onsubmit = function(e) {
  e.preventDefault()

  var note = {
    content: e.target.elements[0].value,
    date: new Date(),
  }

  notes.push(note)
  e.target.elements[0].value = ''
  redrawNotes()
  sendToServer(note)
}
var sendToServer = function(note) {
  var xhttpForPost = new XMLHttpRequest()
  // ...

  xhttpForPost.open('POST', '/new_note_spa', true)
  xhttpForPost.setRequestHeader(
    'Content-type', 'application/json'
  )
  xhttpForPost.send(JSON.stringify(note))
}
```
> Now to post a new note you only need to send a post message to the server and you can handle the new note locally./


# React

## state


```js
  const App = () => {
  const [left, setLeft] = useState(0)
  const [right, setRight] = useState(0)
}
```
> We can use state to create variables that when the
>  setFunction is called it will cause the component to re-render. 

## Callback
```js
const App = () => {
  const [value, setValue] = useState(10)

  const handleClick = () =>
    console.log('clicked the button')

  return (
    <div>
      {value}
      <button onClick={handleClick}>button</button>
    </div>
  )
}
```
> onClick needs to be be handed a function pointer and not a function invocation or else you will receive an error


## Rendering a collection, modules
```js
{notes.map(note => 
          <li key={note.id}>
            {note.content}
          </li>
        )}
```
> elements generated by a list must have a key value so react can determine how to update the generated view on re render 

### Forms   

```js
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState(
    'a new note...'
  ) 
  const addNote = (event) => {
  event.preventDefault()
  const noteObject = {
    content: newNote,
    date: new Date().toISOString(),
    important: Math.random() < 0.5,
    id: notes.length + 1,
  }

  setNotes(notes.concat(noteObject))
  setNewNote('')
}
    const handleNoteChange = (event) => {
    console.log(event.target.value)
    setNewNote(event.target.value)
  }
```
> Prevent default stops page from reloading
> > handle note change makes sure newNote is updated as the user changes the input box on the form
> > > now addNote has the most up to date info on submit and can append the new note
```js
  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
      <form onSubmit={addNote}>
        <input value={newNote} />
        <button type="submit">save</button>
      </form>   
    </div>
  )
}
```

# Getting data from Sever 


All requests are nonblocking IE they will not wait for the return to continue code execution 