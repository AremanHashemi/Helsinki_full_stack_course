# Helsinki_full_stack_course

# Intro

## Callbacks
```js var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  // code that takes care of the server response
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```
> onreadstatechange is called after the request to server is sent on last line. This is an example of a event handler. Event handlers get called on change of state of certain bits.

> Invoking event handlers is done via callback mechanism where the runtime enviroment is in charge of invoking callback functions at the appropriate time.

The DOM or document object model is a treelike structure of HTML elements. 

## AJAX 
Asynchrounous Javascript and XML : allowed fetching content to web pages using javascript within the HTML. No longer need to re render the page.

## Single Page App
Only comprised of one HTML page fetched from the server, the content is then manipulated via javascript to give the feeling of multiple pages without having to make more fetch calls.

```js
var form = document.getElementById('notes_form')
form.onsubmit = function(e) {
  e.preventDefault()

  var note = {
    content: e.target.elements[0].value,
    date: new Date(),
  }

  notes.push(note)
  e.target.elements[0].value = ''
  redrawNotes()
  sendToServer(note)
}
var sendToServer = function(note) {
  var xhttpForPost = new XMLHttpRequest()
  // ...

  xhttpForPost.open('POST', '/new_note_spa', true)
  xhttpForPost.setRequestHeader(
    'Content-type', 'application/json'
  )
  xhttpForPost.send(JSON.stringify(note))
}
```
> Now to post a new note you only need to send a post message to the server and you can handle the new note locally./


# React

## state


```js
  const App = () => {
  const [left, setLeft] = useState(0)
  const [right, setRight] = useState(0)
}
```
> We can use state to create variables that when the
>  setFunction is called it will cause the component to re-render. 

## Callback
```js
const App = () => {
  const [value, setValue] = useState(10)

  const handleClick = () =>
    console.log('clicked the button')

  return (
    <div>
      {value}
      <button onClick={handleClick}>button</button>
    </div>
  )
}
```
> onClick needs to be be handed a function pointer and not a function invocation or else you will receive an error


## Rendering a collection, modules
```js
{notes.map(note => 
          <li key={note.id}>
            {note.content}
          </li>
        )}
```
> elements generated by a list must have a key value so react can determine how to update the generated view on re render 

### Forms   

```js
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState(
    'a new note...'
  ) 
  const addNote = (event) => {
  event.preventDefault()
  const noteObject = {
    content: newNote,
    date: new Date().toISOString(),
    important: Math.random() < 0.5,
    id: notes.length + 1,
  }

  setNotes(notes.concat(noteObject))
  setNewNote('')
}
    const handleNoteChange = (event) => {
    console.log(event.target.value)
    setNewNote(event.target.value)
  }
```
> Prevent default stops page from reloading
> > handle note change makes sure newNote is updated as the user changes the input box on the form
> > > now addNote has the most up to date info on submit and can append the new note
```js
  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
      <form onSubmit={addNote}>
        <input value={newNote} />
        <button type="submit">save</button>
      </form>   
    </div>
  )
}
```

# Getting data from Sever 


All requests are nonblocking IE they will not wait for the return to continue code execution since the javascript runtime engine is single threaded

you can use json-server as a tool for developing this frontend `npx json-server --port 3001 --watch db.json
`
Reads from the file db.json in the root directory of the project      
<br>

### Fetch
Standard request tool
Axios is similar to fetch but more pleasant

#### Package.json 
A config file used by npm, you can look at dependencies, when you run `npm install axios` you should see axios added to the list of dependencies as well as the libary code downloaded in npm_modules
> Install scripts are another usefull part of the package file by running `npm install json-server --save-dev` it adds this command to the scripts object `    "server": "json-server -p3001 --watch db.json"` now by running `npm run server` we can run our json server

### Axios & Promises
```js
import axios from 'axios'

const promise = axios.get('http://localhost:3001/notes')
promise.then(response => {
  console.log(response)
})
```
- ### Promise 
  - A promise is an object representing eventual completion or a failure of an async operation, which can be in three states
      1. Pending: final value is not available yet
      2. Fufilled: operation has completed and final value is avaiable
      3. Rejected: Error prevented final value from being determined
  - Once a promise is fufilled we can use the `then` keyword to write a callback function that runs after completion 

more readable version:
```js 
  axios
  .get('http://localhost:3001/notes')
  .then(response => {
    const notes = response.data
    console.log(notes)
  })
```

## Effect-hooks
Like state hooks but for fetching data
```js
import React, { useState, useEffect } from 'react'
import axios from 'axios'
import Note from './components/Note'

const App = () => {
  const [notes, setNotes] = useState([])
  const [newNote, setNewNote] = useState('')
  const [showAll, setShowAll] = useState(true)

  useEffect(() => {
    console.log('effect')
    axios
      .get('http://localhost:3001/notes')
      .then(response => {
        console.log('promise fulfilled')
        setNotes(response.data)
      })
  }, [])
  console.log('render', notes.length, 'notes')
}

useEffect(hook, [])

```
> Two parameters, 
> > Effects run after every completed render, but you can choose to fire it only when certain values change


## Alterering data in server

### REST
Data objects are refered to as resources, each resource has a unique URL associated with it.  
Resources are fetched with a GET 
```js
import axios from 'axios'
const baseUrl = 'http://localhost:3001/notes'

const getAll = () => {
  return axios.get(baseUrl)
}

const create = newObject => {
  return axios.post(baseUrl, newObject)
}

const update = (id, newObject) => {
  return axios.put(`${baseUrl}/${id}`, newObject)
}

export default { 
  getAll: getAll, 
  create: create, 
  update: update 
}import axios from 'axios'
const baseUrl = 'http://localhost:3001/notes'

const getAll = () => {
  const request = axios.get(baseUrl)
  return request.then(response => response.data)
}

const create = newObject => {
  const request = axios.post(baseUrl, newObject)
  return request.then(response => response.data)
}

const update = (id, newObject) => {
  const request = axios.put(`${baseUrl}/${id}`, newObject)
  return request.then(response => response.data)
}

export default { 
  getAll: getAll, 
  create: create, 
  update: update 
}
```
> Seperate communication functions to src/services directory add notes.js then in the apps component import the services

